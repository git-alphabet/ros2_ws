<root BTCPP_format="4">
  <BehaviorTree ID="IsDeadAndDispelDebuff">
   <!-- A. 战亡：只停车等待复活读条结束 -->
        <Sequence name="IfDead_StopAndWait">
          <IsDead message="{robot_status}"/>
          <RobotControl stop_gimbal_scan="True"
                        chassis_spin_vel="0"/>
        </Sequence>
 
        <!-- B. 恢复模式：复活后强制回补给区刷卡解除虚弱并回血 -->
        <Sequence name="RecoveryMode">

          <!-- 检测复活沿：dead -> alive 时置 need_recovery=true -->
          <DetectRespawnAndSetRecovery
              was_dead="{was_dead}"
              hp_cur="{hp_cur}"
              now_ms="{now_ms}"
              need_recovery="{need_recovery}"
              recovery_start_ms="recovery_start_ms}"
              search_start_ms="{search_start_ms}"/>

          <IsRecoveryNeeded need_recovery="{need_recovery}"/>

          <Fallback name="RecoveryFlow">

            <!-- 成功分支：检测到补给区RFID -> 等待回血 -> 清除恢复flag -->
            <Sequence name="IfSupplyCard_Heal_Exit">
              <!-- TODO：补充RFID.msg里面的补给区交互状态rfid_status -->
              <IsSupplyCardDetected rfid_status="{rfid.status}"/>
              <!-- WaitAndHeal的端口解释看下面 -->
              <WaitAndHeal
                  topic_name="/robot_status"
                  now_ms="{now_ms}"
                  heal_start_ms="{heal_start_ms}"
                  heal_wait_ms="{heal_wait_ms}"
                  hp_cur="{hp_cur}"
                  hp_max="{hp_max}"
                  heal_min_ratio="{heal_min_ratio}"/>
              <!-- 退出恢复模式 -->
              <ClearRecoveryFlag
                  need_recovery="{state.need_recovery}"
                  heal_start_ms="{state.heal_start_ms}"
                  search_start_ms="{state.search_start_ms}"
                  recovery_start_ms="{state.recovery_start_ms}"/>

            </Sequence>

            <!-- 未检测到卡：去补给区 + 到达后执行“微搜卡” -->
            <Sequence name="GoSupply_ThenSearch">

                <!-- 导航目标点=配置的补给区入口/中心 -->
                <SetNavGoalFromConfig
                    cfg_x="{cfg.supply_goal_x}"
                    cfg_y="{cfg.supply_goal_y}"
                    goal_x="{nav.goal_x}"
                    goal_y="{nav.goal_y}"
                    goal_pose="{nav.goal_pose}"/>

                <!-- 外层：任何时刻，补给卡检测最高优先级 -->
                <ReactiveFallback name="CardFirst_ThenNavOrSearch">

                    <!-- 0) 最高优先级：刷到补给卡就立刻让本子树SUCCESS（上层下一拍进入回血/清flag） -->
                    <IsSupplyCardDetected rfid_status="{rfid.status}"/>

                    <!-- 1) 没刷到卡：继续执行“导航到点->微搜卡”流程（持续RUNNING直到刷到卡） -->
                    <Sequence name="NavThenSearchUntilCard">

                        <!-- 内层：到达检测最高优先级 -->
                        <ReactiveFallback name="ArrivedFirst_ThenKeepNavigating">

                            <!-- A) 已到达有效半径：立刻进入微搜（且不再发导航） -->
                            <Sequence name="Arrived_DoMicroSearch">

                                <!-- 到达判断：成立才会进入微搜；不成立则此Sequence直接FAILURE -->
                                <!-- 将位姿与配置的补给区点/到达半径传入 -->
                                <IsWithinScope
                                    pose_x="{pose.x}"
                                    pose_y="{pose.y}"
                                    goal_x="{cfg.supply_goal_x}"
                                    goal_y="{cfg.supply_goal_y}"
                                    arrive_radius="{cfg.arrive_radius}"/>

                                <!-- 到达后先刹车，保证微搜动作可控 -->
                                <RobotControl stop_gimbal_scan="True"
                                            chassis_spin_vel="0.0"/>

                                <!-- 初始化搜卡计时器（内部自己取ROS时间，不需要now_ms） -->
                                <InitSearchTimerIfNeeded search_start_ms="{state.search_start_ms}"/>

                                <!-- 微搜卡：持续RUNNING直到刷到bit19/20；刷到卡由外层ReactiveFallback抢占 -->
                                <MicroSearchSupplyCard
                                    search_start_ms="{state.search_start_ms}"
                                    timeout_ms="{cfg.search_timeout_ms}"
                                    rfid_status="{rfid.status}"/>
                            </Sequence>

                            <!-- B) 未到达：持续发导航，并强制RUNNING -->
                            <Sequence name="StillNavigating">

                                <!-- 未到达时 IsWithinScope 应返回 FAILURE，才能走到这里 -->
                                <SendGoal name="GoSupplyToHeal"
                                    goal_x="{nav.goal_x}"
                                    goal_y="{nav.goal_y}"
                                    min_interval_ms="200"/>

                                <!-- 这里不再放 IsWithinScope，避免“到达瞬间”还多发一拍导航 -->
                                <KeepRunning/>
                            </Sequence>

                        </ReactiveFallback>

                        <!-- 兜底保持RUNNING：确保整段流程在未刷卡前不会返回SUCCESS -->
                        <KeepRunning/>

                    </Sequence>

                </ReactiveFallback>

            </Sequence>

          </Fallback>

        </Sequence>
  </BehaviorTree>

  <TreeNodesModel>

    

    <!-- ========== 你们自己的作战入口 ========== -->

    <Action ID="CombatMain" editable="true">
    </Action>
        <Action ID="SendGoal" editable="true">
            <input_port name="goal_pose" default="{goal_pose}"/>
            <input_port name="goal_x" default="0.0"/>
            <input_port name="goal_y" default="0.0"/>
            <input_port name="action_name" default="navigate_to_pose"/>
        </Action>

  </TreeNodesModel>

</root>
